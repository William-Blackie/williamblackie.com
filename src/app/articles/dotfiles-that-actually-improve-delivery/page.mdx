import { ArticleLayout } from '@/components/ArticleLayout'

export const article = {
  author: 'William Blackie',
  date: '2026-02-22',
  title: 'Dotfiles for adults: less terminal cosplay, more useful flow',
  description:
    'A practical approach to dotfiles that improves delivery quality, reduces friction, and supports team workflows.',
}

export const metadata = {
  title: article.title,
  description: article.description,
}

<ArticleLayout article={article}>
I like a pretty terminal. I also like not wasting half an hour a day on avoidable friction.

Only one of those survives contact with real delivery pressure.

I maintain [my dotfiles](https://github.com/William-Blackie/.dotfiles) because local setup quality compounds. Tiny paper-cuts stack up: one command you always forget, one alias that behaves differently per machine, one editor quirk that drags you out of flow. None is catastrophic. Together they are a tax on judgement.

When teams say "we need to move faster", they often jump straight to architecture conversations. Reasonable instinct. But there is another lever: reduce local cognitive drag so engineers spend less time context-switching and more time making good decisions.

That is what dotfiles are for when used well.

## My rule: configuration must earn its place

Over time I removed most "clever" customisation and kept only what pays off repeatedly.

A config stays if it does one of these:

1. reduces repeated context switches;
2. makes common commands predictable;
3. lowers setup cost for new/temporary machines;
4. helps me move from question to verified change quickly.

If it mostly makes me feel fancy, it gets deleted.

I’ve become quite ruthless here. The terminal is a workplace, not a theme park.

## What actually helps me deliver better

The biggest gains in my setup are boring and consistent.

- Fast discovery: `fzf` + `ripgrep` for finding files and symbols quickly.
- Session continuity: `tmux` for long-running contexts and safer multitasking.
- Predictable shell behaviour: minimal aliases, obvious names, consistent flags.
- Editor ergonomics: Neovim defaults tuned for readability and navigation speed, not novelty.
- Script-first mindset: project-critical operations live in repo scripts/Make targets, not only in my shell.

The last point is the one that matters most for teams.

## A hard boundary: personal setup must not hide team workflows

I made this mistake earlier in my career and I still see it often: moving essential project behaviour into private shell magic.

It feels fast for one engineer. It is fragile for everyone else.

If a command matters to delivery, it belongs in the project:

- `make` targets;
- `npm` scripts;
- documented runbooks;
- CI pipelines that mirror local checks.

Dotfiles should support shared workflows, not replace them.

A quick test I use: if I disappear for two weeks, can the team run the same workflow without guessing? If not, I’ve put too much in my personal layer.

## Why this is really about reliability, not preference

Good local tooling improves more than typing speed.

It helps where engineering is expensive:

1. incident triage, when you need fast, accurate investigation;
2. release windows, when confidence matters more than cleverness;
3. onboarding, when setup friction can burn a full week;
4. refactors, when context breadth is high and mistakes are easy.

Stable local workflows preserve cognitive bandwidth for architecture, debugging, and user-impact decisions.

That is a reliability outcome, not just a productivity vibe.

## How I keep dotfiles healthy over time

I treat dotfiles like a small product:

1. Keep changes incremental.
2. Prefer explicit over magical.
3. Document non-obvious behaviour.
4. Remove old tweaks aggressively.
5. Re-check setup on fresh machines periodically.

If setup becomes a puzzle, the system has drifted.

## Final thought

Dotfiles are not about being "that engineer with the dramatic terminal".

They are about reducing repeat friction so your best attention goes to the hard problems, not to command archaeology.

Good dotfiles are quietly useful. They don’t perform. They support.

And if your prompt looks nice at the same time, that is a perfectly acceptable bonus.

## References

- [My dotfiles](https://github.com/William-Blackie/.dotfiles)
- [tmux](https://github.com/tmux/tmux)
- [fzf](https://github.com/junegunn/fzf)
- [ripgrep](https://github.com/BurntSushi/ripgrep)
- [The Twelve-Factor App: dev/prod parity](https://12factor.net/dev-prod-parity)
</ArticleLayout>
