import { ArticleLayout } from '@/components/ArticleLayout'

export const article = {
  author: 'William Blackie',
  date: '2026-02-22',
  title: 'Dotfiles for adults: less terminal cosplay, more useful flow',
  description:
    'Why I keep my dotfiles boring on purpose, and how that reduces delivery friction in real teams.'
}

export const metadata = {
  title: article.title,
  description: article.description,
}

<ArticleLayout article={article}>
I like a nice terminal as much as the next engineer. I also like not wasting half an hour a day on avoidable friction.

Only one of those survives contact with real delivery work.

I maintain [my dotfiles](https://github.com/William-Blackie/.dotfiles) because local friction compounds quietly. One alias that behaves differently per machine. One setup step you always forget. One command you run daily that still feels like a scavenger hunt. None is catastrophic. Together they are a tax on judgement.

When teams say “we need to move faster”, they often jump straight to architecture. Sensible instinct. But there is another lever: reduce local cognitive drag so engineers spend less time context‑switching and more time making good decisions.

That is what dotfiles are for when used well.

## My rule: config has to earn its place

Over time I removed most “clever” customisation and kept only what pays off repeatedly. If a tweak mostly makes me feel clever, it does not survive. If it helps me move from question to verified change with less noise, it stays.

The terminal is a workplace, not a theme park.

## What actually helps me deliver better

The biggest wins are boring and consistent:

- fast discovery (`fzf` + `ripgrep` for finding files and symbols);
- stable sessions (`tmux` for long‑running contexts);
- predictable shell behaviour (minimal aliases, obvious names, consistent flags);
- editor ergonomics (Neovim tuned for readability and navigation speed, not novelty);
- script‑first workflow (project‑critical operations live in repo scripts/Make targets, not in my shell).

That last one is the one that matters most for teams.

## A hard boundary: personal setup must not hide team workflows

I made this mistake earlier in my career and I still see it often: moving essential project behaviour into private shell magic.

It feels fast for one engineer. It is fragile for everyone else.

If a command matters to delivery, it belongs in the project. Dotfiles should support shared workflows, not replace them.

A quick test I use: if I disappear for two weeks, can the team run the same workflow without guessing? If not, I put too much in my personal layer.

## Why this is really about reliability, not preference

Good local tooling improves more than typing speed. It helps where engineering is expensive:

- incident triage, when you need fast, accurate investigation;
- release windows, when confidence matters more than cleverness;
- onboarding, when setup friction can burn a full week;
- refactors, when context breadth is high and mistakes are easy.

Stable local workflows preserve cognitive bandwidth for architecture, debugging and user‑impact decisions. That is a reliability outcome, not a productivity vibe.

## Final thought

Dotfiles are not about being “that engineer with the dramatic terminal”. They are about reducing repeat friction so your best attention goes to the hard problems, not to command archaeology.

Good dotfiles are quietly useful. They don’t perform. They support.

And if your prompt looks nice at the same time, that is a perfectly acceptable bonus.

## References

- [My dotfiles](https://github.com/William-Blackie/.dotfiles)
- [tmux](https://github.com/tmux/tmux)
- [fzf](https://github.com/junegunn/fzf)
- [ripgrep](https://github.com/BurntSushi/ripgrep)
- [The Twelve-Factor App: dev/prod parity](https://12factor.net/dev-prod-parity)
</ArticleLayout>
